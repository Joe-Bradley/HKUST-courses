<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Volatility Models in Option</title>
    <meta charset="utf-8" />
    <meta name="author" content="xiaoli_209255438" />
    <script src="libs/header-attrs-2.16/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="zh-CN.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Volatility Models in Option
]
.author[
### xiaoli_209255438
]
.date[
### 5 Dec 2022
]

---


.pull-left[
### Volatility models
- **Standard deviation(SD)**

`$$\sigma=\sqrt{\frac{1}{n-1}\sum_{i=1}^n(X_i-\bar{X})}$$`

- **Exponentially Weighted Moving Average(EWMA)** 

`$$\sigma_n = \lambda\sigma_{n-1}^2 + (1-\lambda)u_{n-1}^2$$`

- **Generalized AutoRegressive Conditional Heteroskedasticity(GARCH)**


`$$\sigma_n = (1-\alpha-\beta)V_L + \alpha u_{n-1}^2 + \beta\sigma_{n-1}^2$$`

- **Stochastic Volatility(SA)**

`$$d\nu_t = \alpha_{\nu,t}dt+\beta_{\nu,t}dB_t$$`
]

.pull-right[
### Option pricing models
- **Simple Black-Scholes**
`$$Call = Se^{-qt}N(d_1)-Ke^{-rt}N(d_2)$$`
`$$Put = Ke^{-rt}N(-d_2)-Se^{-qt}N(-d_1)$$`
`$$d_{1,2}= \frac{log(\frac{S}{K})+(r-q\pm\frac{\sigma^2}{2})t}{\sigma\sqrt{t}}$$`

- **The Heston Model**
`$$dS_t = \mu S_td_t + \sqrt{v_t}S_tdW_1$$`
`$$dv_t = \alpha(S_t, v_t, t)d_t + \sigma \beta(S_t, v_t, t)dW2$$`
$$dW_1 \cdot dW_2 = \rho dt $$
`$$parameter = (v_0, \theta, \rho, \kappa, \xi)$$`

]
---
#Results

3month-call option on Apple Inc. with following parameter.
- K = 120, S = 148.11, R = 0.0421, T = 0.25, Q = 0.0061, Actual call price = 31.35

```
##                     BSM_SD    BSM_EWMA    BSM_GARCH      BSM_SV Actual
## 1 In-the-Money 26.74217757  27.1084363  26.91855601 30.34989122  31.35
## 2 Out-of-Money           0 1.129831294 0.6713966474 2.089795823   2.19
```

Conclude:
- The results of standard deviation, EWMA, GARCH seems to be inaccurate. The most possible reason is that the calculation formula is based on European style, while the option provided by APPLE Inc.(AAPL) is American type. The actual trading option price must be higher than or equal to the results computed by Black-Scholes equation.

- Since the stochastic volatility models are calibrated to satisfy the implied volatility from the real market, the model capture the forward looking factors in the market. As a consequence, The Heston Model offers more precise prediction in option pricing.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
